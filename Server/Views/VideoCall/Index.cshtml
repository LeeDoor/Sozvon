@{
    ViewData["Title"] = "Видеокомнаты";
}

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Видеокомнаты</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 30px;
            text-align: center;
        }

            .header h1 {
                font-size: 2.5em;
                margin-bottom: 10px;
            }

        .content {
            display: flex;
            min-height: 600px;
        }

        /* Панель управления комнатами */
        .room-panel {
            width: 350px;
            background: #f8f9fa;
            padding: 30px;
            border-right: 1px solid #e9ecef;
        }

        .room-section {
            margin-bottom: 30px;
        }

            .room-section h3 {
                color: #2c3e50;
                margin-bottom: 20px;
                font-size: 1.3em;
            }

        .form-group {
            margin-bottom: 20px;
        }

            .form-group label {
                display: block;
                margin-bottom: 8px;
                font-weight: 600;
                color: #495057;
            }

        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

            .form-control:focus {
                border-color: #667eea;
                outline: none;
            }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

            .btn-primary:hover {
                background: #5a6fd8;
            }

        .btn-success {
            background: #28a745;
            color: white;
        }

            .btn-success:hover {
                background: #218838;
            }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

            .btn-danger:hover {
                background: #c82333;
            }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

            .btn-warning:hover {
                background: #e0a800;
            }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .room-info {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            margin-top: 20px;
        }

        .room-id {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            word-break: break-all;
            font-size: 14px;
        }

        .users-count {
            color: #667eea;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* Область видео */
        .video-area {
            flex: 1;
            padding: 30px;
            background: #2c3e50;
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .video-wrapper {
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            aspect-ratio: 16/9;
        }

            .video-wrapper.own-video {
                border: 3px solid #667eea;
            }

            .video-wrapper.remote-video {
                border: 2px solid #34495e;
            }

        .video-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.7));
            padding: 20px;
            color: white;
        }

        .user-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .user-status {
            display: flex;
            gap: 10px;
            font-size: 14px;
        }

        .status-icon {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .controls-bar {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 15px 25px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
            min-width: 160px;
        }

            .control-btn.active {
                background: #28a745;
                color: white;
            }

            .control-btn.inactive {
                background: #dc3545;
                color: white;
            }

            .control-btn.leave {
                background: #ff6b6b;
                color: white;
            }

            .control-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            }

        /* Состояния */
        .state-connected {
            color: #28a745;
        }

        .state-disconnected {
            color: #dc3545;
        }

        .state-waiting {
            color: #ffc107;
        }

        .hidden {
            display: none;
        }

        /* Адаптивность */
        @("@media (max-width: 1024px)")

        {
            .content

        {
            flex-direction: column;
        }

        .room-panel {
            width: 100%;
            border-right: none;
            border-bottom: 1px solid #e9ecef;
        }

        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎥 Видеокомнаты</h1>
            <p>Создавайте комнаты и общайтесь с друзьями</p>
        </div>

        <div class="content">
            <!-- Панель управления комнатами -->
            <div class="room-panel">
                <div class="room-section">
                    <h3>📋 Создать комнату</h3>
                    <div class="form-group">
                        <label for="roomName">Название комнаты (необязательно):</label>
                        <input type="text" id="roomName" class="form-control" placeholder="Моя комната">
                    </div>
                    <button id="createRoomBtn" class="btn btn-primary">🎪 Создать комнату</button>
                </div>

                <div class="room-section">
                    <h3>🔗 Присоединиться к комнате</h3>
                    <div class="form-group">
                        <label for="joinRoomId">ID комнаты:</label>
                        <input type="text" id="joinRoomId" class="form-control" placeholder="Введите 20-символьный ID">
                    </div>
                    <button id="joinRoomBtn" class="btn btn-success">🚪 Присоединиться</button>
                </div>

                <!-- Информация о текущей комнате -->
                <div id="currentRoomInfo" class="room-info hidden">
                    <h3>🏠 Текущая комната</h3>
                    <div><strong>Название:</strong> <span id="roomNameDisplay">-</span></div>
                    <div><strong>ID:</strong> <div id="roomIdDisplay" class="room-id"></div></div>
                    <div><strong>Участников:</strong> <span id="roomUsersCount" class="users-count">0</span>/30</div>
                    <button id="leaveRoomBtn" class="btn btn-danger">👋 Покинуть комнату</button>
                </div>
            </div>

            <!-- Область видео -->
            <div class="video-area">
                <!-- Сетка видео -->
                <div id="videoGrid" class="video-grid">
                    <!-- Свое видео -->
                    <div class="video-wrapper own-video">
                        <video id="localVideo" autoplay muted playsinline></video>
                        <div class="video-overlay">
                            <div class="user-name">Вы</div>
                            <div class="user-status">
                                <div class="status-icon">📹 <span id="cameraStatus">Выкл</span></div>
                                <div class="status-icon">🎤 <span id="micStatus">Выкл</span></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Панель управления -->
                <div id="controlsBar" class="controls-bar hidden">
                    <button id="toggleCameraBtn" class="control-btn inactive">
                        📹 Выключить камеру
                    </button>
                    <button id="toggleMicBtn" class="control-btn inactive">
                        🎤 Выключить микрофон
                    </button>
                    <button id="disconnectBtn" class="control-btn leave">
                        📞 Покинуть комнату
                    </button>
                    <button id="syncConnectionsBtn" class="control-btn" style="background: #17a2b8;">
                        🔄 Синхронизировать
                    </button>
                </div>

                <!-- Сообщение когда нет подключения -->
                <div id="noConnectionMessage" style="text-align: center; color: white; padding: 50px;">
                    <h2>Добро пожаловать! 👋</h2>
                    <p>Создайте новую комнату или присоединитесь к существующей чтобы начать общение</p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.5/signalr.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Переменные
            let localStream = null;
            let peerConnections = new Map();
            let connection = null;
            let currentRoom = null;
            let isCameraOn = false;
            let isMicrophoneOn = false;

            // Элементы
            const localVideo = document.getElementById('localVideo');
            const videoGrid = document.getElementById('videoGrid');
            const controlsBar = document.getElementById('controlsBar');
            const noConnectionMessage = document.getElementById('noConnectionMessage');
            const currentRoomInfo = document.getElementById('currentRoomInfo');

            // Кнопки комнат
            const createRoomBtn = document.getElementById('createRoomBtn');
            const joinRoomBtn = document.getElementById('joinRoomBtn');
            const leaveRoomBtn = document.getElementById('leaveRoomBtn');
            const syncConnectionsBtn = document.getElementById('syncConnectionsBtn');

            // Кнопки управления
            const toggleCameraBtn = document.getElementById('toggleCameraBtn');
            const toggleMicBtn = document.getElementById('toggleMicBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');

            // Статусы
            const cameraStatus = document.getElementById('cameraStatus');
            const micStatus = document.getElementById('micStatus');
            const roomNameDisplay = document.getElementById('roomNameDisplay');
            const roomIdDisplay = document.getElementById('roomIdDisplay');
            const roomUsersCount = document.getElementById('roomUsersCount');

            console.log('WebRTC application initializing...');
                    window.addEventListener('error', function(e) {
            console.error('Global error:', e.error);
        });
            // Блокируем кнопки до подключения
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;

            // Инициализация SignalR
            async function initializeSignalR() {
                try {
                    connection = new signalR.HubConnectionBuilder()
                        .withUrl("/webrtchub")
                        .build();

                    // Обработчики событий
                    connection.on("UserJoined", (userInfo) => {
                        console.log('Новый пользователь:', userInfo);
                        addUserVideo(userInfo);
                        updateUsersCount();

                        // Если камера включена, ждем немного и начинаем звонок
                        if (isCameraOn && localStream) {
                            setTimeout(async () => {
                                await startCallWithUser(userInfo.userId);
                            }, 500);
                        }
                    });

                    connection.on("UserLeft", (userId) => {
                        console.log('Пользователь вышел:', userId);
                        removeUserVideo(userId);
                        updateUsersCount();
                    });

                    connection.on("UserMediaUpdated", (data) => {
                        console.log('Обновление медиа:', data);
                        updateUserMediaState(data.userId, data.hasCamera, data.hasMicrophone);

                        // Если пользователь выключил камеру, очищаем его видео
                        if (!data.hasCamera) {
                            const remoteVideo = document.getElementById(`remoteVideo-${data.userId}`);
                            if (remoteVideo) {
                                remoteVideo.srcObject = null;
                            }
                        }
                    });

                    connection.on("ReceiveSignal", async (data) => {
                        await handleSignal(data);
                    });

                    await connection.start();
                    console.log('SignalR подключен');

                    // Разблокируем кнопки после подключения
                    createRoomBtn.disabled = false;
                    joinRoomBtn.disabled = false;

                } catch (error) {
                    console.error('Ошибка SignalR:', error);
                    alert('Ошибка подключения к серверу: ' + error.message);
                }
            }

            // Создать комнату
            createRoomBtn.addEventListener('click', async () => {
                if (!connection || connection.state !== 'Connected') {
                    alert('Подождите, подключение к серверу...');
                    return;
                }

                const roomName = document.getElementById('roomName').value;

                try {
                    createRoomBtn.disabled = true;
                    const roomInfo = await connection.invoke("CreateRoom", roomName);
                    await joinRoom(roomInfo.roomId);
                } catch (error) {
                    alert('Ошибка создания комнаты: ' + error.message);
                    createRoomBtn.disabled = false;
                }
            });

            // Присоединиться к комнате
            joinRoomBtn.addEventListener('click', async () => {
                if (!connection || connection.state !== 'Connected') {
                    alert('Подождите, подключение к серверу...');
                    return;
                }

                const roomId = document.getElementById('joinRoomId').value.trim();

                if (roomId.length !== 20) {
                    alert('ID комнаты должен содержать 20 символов');
                    return;
                }

                try {
                    joinRoomBtn.disabled = true;
                    await joinRoom(roomId);
                } catch (error) {
                    alert('Ошибка подключения: ' + error.message);
                    joinRoomBtn.disabled = false;
                }
            });

            // Присоединиться к комнате
            async function joinRoom(roomId) {
            try {
                const result = await connection.invoke("JoinRoom", roomId, "");

                if (result.success) {
                    currentRoom = result.roomInfo;
                    showRoomInterface();

                    // Добавляем существующих пользователей
                    if (result.existingUsers) {
                        result.existingUsers.forEach(user => addUserVideo(user));
                    }

                    // Запрашиваем видео у всех пользователей (даже если камера выключена)
                    setTimeout(() => {
                        requestVideoFromAll();
                    }, 1000);

                } else {
                    alert('Ошибка: ' + result.error);
                    createRoomBtn.disabled = false;
                    joinRoomBtn.disabled = false;
                }
            } catch (error) {
                alert('Ошибка подключения: ' + error.message);
                createRoomBtn.disabled = false;
                joinRoomBtn.disabled = false;
            }
        }

            // Покинуть комнату
            leaveRoomBtn.addEventListener('click', async () => {
                if (currentRoom) {
                    await connection.invoke("LeaveRoom", currentRoom.roomId);
                    leaveRoom();
                }
            });

            disconnectBtn.addEventListener('click', async () => {
                if (currentRoom) {
                    await connection.invoke("LeaveRoom", currentRoom.roomId);
                    leaveRoom();
                }
            });
            
            // Обработчик синхронизации
            syncConnectionsBtn.addEventListener('click', async () => {
                await syncAllConnections();
            });

            // Переключение камеры
            toggleCameraBtn.addEventListener('click', async () => {
                if (!isCameraOn) {
                    await startCamera();
                } else {
                    stopCamera();
                }
                updateMediaState();
            });

            // Переключение микрофона
            toggleMicBtn.addEventListener('click', async () => {
                if (localStream) {
                    const audioTracks = localStream.getAudioTracks();
                    audioTracks.forEach(track => {
                        track.enabled = !track.enabled;
                    });
                    isMicrophoneOn = !isMicrophoneOn;
                    updateMediaState();
                }
            });

                    // Запуск камеры
        async function startCamera() {
            try {
                console.log('Starting camera...');
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 },
                    audio: true
                });

                localVideo.srcObject = localStream;
                isCameraOn = true;
                isMicrophoneOn = true;

                console.log('Camera started, adding tracks to existing PeerConnections');

                // Добавляем треки во ВСЕ существующие PeerConnection
                const promises = [];
                peerConnections.forEach((pc, userId) => {
                    if (localStream) {
                        console.log('Adding tracks to existing PeerConnection for user:', userId);
                        localStream.getTracks().forEach(track => {
                            // Используем replaceTrack если sender уже существует, иначе addTrack
                            const sender = pc.getSenders().find(s =>
                                s.track && s.track.kind === track.kind
                            );
                            if (sender) {
                                sender.replaceTrack(track);
                            } else {
                                pc.addTrack(track, localStream);
                            }
                        });

                        // Переотправляем offer чтобы обновить треки
                        promises.push(new Promise(resolve => {
                            setTimeout(async () => {
                                await restartCallWithUser(userId);
                                resolve();
                            }, 100);
                        }));
                    }
                });

                await Promise.all(promises);
                console.log('All calls restarted with camera');

            } catch (error) {
                console.error('Ошибка доступа к камере:', error);
                alert('Ошибка доступа к камере: ' + error.message);
            }
        }

                // Перезапустить звонок с пользователем (при повторном включении камеры)
        async function restartCallWithUser(userId) {
            console.log('Restarting call with user:', userId);

            const pc = peerConnections.get(userId);
            if (!pc) {
                console.error('No PeerConnection for user:', userId);
                return;
            }

            try {
                // Создаем новый offer с обновленными треками
                const offer = await pc.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });

                console.log('Created new offer for user:', userId, offer.type);
                await pc.setLocalDescription(offer);

                await connection.invoke("SendSignal", userId, {
                    type: 'offer',
                    offer: offer
                });

                console.log('New offer sent to user:', userId);
            } catch (error) {
                console.error('Ошибка перезапуска звонка:', error);
            }
        }

                    // Остановка камеры
        function stopCamera() {
            if (localStream) {
                // Останавливаем только локальные треки, но НЕ закрываем PeerConnection
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                localVideo.srcObject = null;
                isCameraOn = false;
                isMicrophoneOn = false;

                console.log('Camera stopped, but keeping PeerConnections for receiving video');

                // Удаляем только отправляющие треки из PeerConnection, но сами соединения оставляем
                removeLocalTracksFromPeerConnections();
            }
        }

                // Удалить локальные треки из всех PeerConnection
        function removeLocalTracksFromPeerConnections() {
            peerConnections.forEach((pc, userId) => {
                // Получаем все отправляющие треки
                const senders = pc.getSenders();
                senders.forEach(sender => {
                    // Удаляем только видео и аудио треки, оставляя соединение активным
                    if (sender.track && (sender.track.kind === 'video' || sender.track.kind === 'audio')) {
                        pc.removeTrack(sender);
                    }
                });
            });
            console.log('Local tracks removed from all PeerConnections');
        }

                    // Очистить все удаленные видео (теперь используется только при выходе из комнаты)
        function clearAllRemoteVideos() {
            console.log('Clearing all remote videos (leaving room)');

            const remoteVideos = videoGrid.querySelectorAll('.remote-video video');
            remoteVideos.forEach(video => {
                video.srcObject = null;
            });

            // Обновляем статусы медиа у всех пользователей
            const remoteVideoWrappers = videoGrid.querySelectorAll('.remote-video');
            remoteVideoWrappers.forEach(wrapper => {
                const userId = wrapper.id.replace('user-', '');
                updateUserMediaState(userId, false, false);
            });
        }

            // Обновление состояния медиа на сервере
            async function updateMediaState() {
                if (connection) {
                    await connection.invoke("UpdateMediaState", isCameraOn, isMicrophoneOn);
                }

                // Обновляем UI
                cameraStatus.textContent = isCameraOn ? 'Вкл' : 'Выкл';
                micStatus.textContent = isMicrophoneOn ? 'Вкл' : 'Выкл';

                toggleCameraBtn.textContent = isCameraOn ? '📹 Выключить камеру' : '📹 Включить камеру';
                toggleCameraBtn.className = isCameraOn ? 'control-btn active' : 'control-btn inactive';

                toggleMicBtn.textContent = isMicrophoneOn ? '🎤 Выключить микрофон' : '🎤 Включить микрофон';
                toggleMicBtn.className = isMicrophoneOn ? 'control-btn active' : 'control-btn inactive';
            }

            // Показать интерфейс комнаты
            function showRoomInterface() {
                noConnectionMessage.classList.add('hidden');
                controlsBar.classList.remove('hidden');
                currentRoomInfo.classList.remove('hidden');

                roomNameDisplay.textContent = currentRoom.roomName;
                roomIdDisplay.textContent = currentRoom.roomId;
                updateUsersCount();
            }

                   // Покинуть комнату
        function leaveRoom() {
            stopCamera();
            currentRoom = null;

            // Очищаем видео других пользователей
            clearAllRemoteVideos();

            // Затем удаляем элементы
            const remoteVideoWrappers = videoGrid.querySelectorAll('.remote-video');
            remoteVideoWrappers.forEach(video => video.remove());

            noConnectionMessage.classList.remove('hidden');
            controlsBar.classList.add('hidden');
            currentRoomInfo.classList.add('hidden');

            // Закрываем ВСЕ PeerConnection только при выходе из комнаты
            peerConnections.forEach(pc => pc.close());
            peerConnections.clear();

            console.log('Left room, all PeerConnections closed');
        }

            // Добавить видео пользователя
            function addUserVideo(userInfo) {
            // Проверяем не добавлен ли уже пользователь
            if (document.getElementById(`user-${userInfo.userId}`)) {
                console.log('User already exists:', userInfo.userId);
                return;
            }

            const videoWrapper = document.createElement('div');
            videoWrapper.className = 'video-wrapper remote-video';
            videoWrapper.id = `user-${userInfo.userId}`;

            videoWrapper.innerHTML = `
                <video id="remoteVideo-${userInfo.userId}" autoplay playsinline></video>
                <div class="video-overlay">
                    <div class="user-name">${userInfo.userName}</div>
                    <div class="user-status">
                        <div class="status-icon">📹 <span class="camera-status">Выкл</span></div>
                        <div class="status-icon">🎤 <span class="mic-status">Выкл</span></div>
                    </div>
                </div>
            `;

            videoGrid.appendChild(videoWrapper);
            updateUsersCount();

            // ВСЕГДА создаем PeerConnection для нового пользователя
            console.log('Creating PeerConnection for new user:', userInfo.userId);
            createPeerConnection(userInfo.userId);

            // Если у нас включена камера, начинаем звонок с небольшой задержкой
            if (isCameraOn && localStream) {
                setTimeout(async () => {
                    await startCallWithUser(userInfo.userId);
                }, 300);
            }
        }

            // Начать звонок с пользователем
            async function startCallWithUser(userId) {
            console.log('Starting call with user:', userId);

            const pc = peerConnections.get(userId);
            if (!pc) {
                console.error('No PeerConnection for user:', userId);
                return;
            }

            // Проверяем состояние PeerConnection
            if (pc.signalingState !== 'stable') {
                console.log('PeerConnection not stable, waiting...', pc.signalingState);
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            try {
                const offer = await pc.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });

                console.log('Created offer for user:', userId, offer.type);
                await pc.setLocalDescription(offer);

                await connection.invoke("SendSignal", userId, {
                    type: 'offer',
                    offer: offer
                });

                console.log('Offer sent to user:', userId);
            } catch (error) {
                console.error('Ошибка начала звонка:', error);
                // Пробуем еще раз через секунду
                setTimeout(async () => {
                    await startCallWithUser(userId);
                }, 1000);
            }
        }

            // Удалить видео пользователя
            function removeUserVideo(userId) {
            const videoElement = document.getElementById(`user-${userId}`);
            if (videoElement) {
                // Сначала очищаем видео
                const remoteVideo = videoElement.querySelector('video');
                if (remoteVideo) {
                    remoteVideo.srcObject = null;
                }
                // Затем удаляем элемент
                videoElement.remove();
            }

            // Закрываем PeerConnection
            if (peerConnections.has(userId)) {
                peerConnections.get(userId).close();
                peerConnections.delete(userId);
            }

            updateUsersCount();
        }

            // Обновить состояние медиа пользователя
            function updateUserMediaState(userId, hasCamera, hasMicrophone) {
            const videoElement = document.getElementById(`user-${userId}`);
            if (videoElement) {
                const cameraStatus = videoElement.querySelector('.camera-status');
                const micStatus = videoElement.querySelector('.mic-status');
                const remoteVideo = videoElement.querySelector('video');

                if (cameraStatus) cameraStatus.textContent = hasCamera ? 'Вкл' : 'Выкл';
                if (micStatus) micStatus.textContent = hasMicrophone ? 'Вкл' : 'Выкл';

                // Если камера выключена, очищаем видео
                if (!hasCamera && remoteVideo && remoteVideo.srcObject) {
                    remoteVideo.srcObject = null;
                }
            }
        }

            // Обновить счетчик пользователей
            function updateUsersCount() {
                const userCount = videoGrid.querySelectorAll('.remote-video').length + 1;
                roomUsersCount.textContent = userCount;
            }

            // Создать PeerConnection для существующих пользователей
            function createPeerConnectionsForExistingUsers() {
            const remoteVideos = videoGrid.querySelectorAll('.remote-video');
            console.log('Creating PeerConnections for', remoteVideos.length, 'existing users');

            remoteVideos.forEach(video => {
                const userId = video.id.replace('user-', '');
                if (!peerConnections.has(userId)) {
                    console.log('Creating PeerConnection for existing user:', userId);
                    createPeerConnection(userId);

                    // Если камера включена, отправляем offer
                    if (isCameraOn && localStream) {
                        startCallWithUser(userId);
                    }
                }
            });
        }


                    // Создать PeerConnection
        function createPeerConnection(userId) {
            console.log('Creating PeerConnection for user:', userId);

            const pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ],
                iceCandidatePoolSize: 10
            });

            // Добавляем локальные треки ТОЛЬКО если камера включена
            if (localStream && isCameraOn) {
                console.log('Adding local tracks to PeerConnection for user:', userId);
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
            }

            // Обработчик удаленного потока - ВАЖНО! Этот обработчик всегда активен
            pc.ontrack = (event) => {
                console.log('✅ Received remote track from user:', userId, event.streams[0]);
                const remoteVideo = document.getElementById(`remoteVideo-${userId}`);
                if (remoteVideo && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    updateUserMediaState(userId, true, true);
                }
            };

            // ICE кандидаты
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate to:', userId, event.candidate);
                    connection.invoke("SendSignal", userId, {
                        type: 'ice-candidate',
                        candidate: event.candidate
                    }).catch(err => console.error('Error sending ICE candidate:', err));
                }
            };

            // Отладочная информация
            pc.onconnectionstatechange = () => {
                console.log(`PeerConnection state for ${userId}:`, pc.connectionState);

                // Если соединение разорвано, очищаем видео
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                    const remoteVideo = document.getElementById(`remoteVideo-${userId}`);
                    if (remoteVideo) {
                        remoteVideo.srcObject = null;
                        updateUserMediaState(userId, false, false);
                    }
                }
            };

            pc.oniceconnectionstatechange = () => {
                console.log(`ICE connection state for ${userId}:`, pc.iceConnectionState);
            };

            peerConnections.set(userId, pc);
            return pc;
        }

            // Обработка сигналов WebRTC
            async function handleSignal(data) {
            console.log('Received signal from:', data.senderId, 'type:', data.signal.type);

            let pc = peerConnections.get(data.senderId);

            if (!pc) {
                console.log('Creating new PeerConnection for incoming signal from:', data.senderId);
                pc = createPeerConnection(data.senderId);
                // Ждем инициализации
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            try {
                if (data.signal.type === 'offer') {
                    console.log('Processing offer from:', data.senderId);
                    await pc.setRemoteDescription(new RTCSessionDescription(data.signal.offer));

                    const answer = await pc.createAnswer();
                    console.log('Created answer for:', data.senderId, answer.type);
                    await pc.setLocalDescription(answer);

                    await connection.invoke("SendSignal", data.senderId, {
                        type: 'answer',
                        answer: answer
                    });

                    console.log('Answer sent to:', data.senderId);
                }
                else if (data.signal.type === 'answer') {
                    console.log('Processing answer from:', data.senderId);
                    await pc.setRemoteDescription(new RTCSessionDescription(data.signal.answer));
                }
                else if (data.signal.type === 'ice-candidate') {
                    console.log('Processing ICE candidate from:', data.senderId);
                    if (data.signal.candidate) {
                        await pc.addIceCandidate(new RTCIceCandidate(data.signal.candidate));
                    }
                }
            } catch (error) {
                console.error('Ошибка обработки сигнала:', error);
                // Пробуем еще раз через секунду
                setTimeout(async () => {
                    await handleSignal(data);
                }, 1000);
            }
        }

            // Синхронизировать все соединения
            async function syncAllConnections() {
            console.log('Syncing all connections...');

            if (isCameraOn && localStream) {
                const promises = [];
                peerConnections.forEach((pc, userId) => {
                    if (pc.connectionState !== 'connected' && pc.signalingState === 'stable') {
                        promises.push(startCallWithUser(userId));
                    }
                });

                await Promise.all(promises);
                console.log('Sync completed');
            }
        }

            // Запросить видео у всех пользователей (если камера выключена)
            function requestVideoFromAll() {
            if (!isCameraOn) {
                console.log('Requesting video from all users (camera is off)');
                peerConnections.forEach((pc, userId) => {
                    // Создаем offer даже без локальных треков - это запросит видео у другого пользователя
                    startCallWithUser(userId);
                });
            }
        }

            // Инициализация при загрузке
            initializeSignalR().then(() => {
                console.log('Приложение инициализировано');
            }).catch(error => {
                console.error('Ошибка инициализации:', error);
            });
        });
    </script>
</body>
</html>